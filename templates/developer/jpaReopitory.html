
<div>

    <p>La interfaz JpaRepository es parte de Spring Data JPA, un módulo de Spring que facilita muchísimo el trabajo con bases de datos relacionales a través de JPA (Java Persistence API).</p>

    <h3>¿Qué es JpaRepository?</h3>
    <ul>
        <li>
            Es una interfaz genérica que extiende otras interfaces de Spring Data:
            <ul>
                <li>Repository&lt;T, ID&gt; → la más básica.</li>
                <li>CrudRepository&lt;T, ID&gt; → añade operaciones CRUD.</li>
                <li>PagingAndSortingRepository&lt;T, ID&gt; → agrega soporte de paginación y ordenamiento.</li>
            </ul>
        </li>
        <li>Se usa como capa de acceso a datos (DAO) para entidades JPA, evitando escribir implementaciones manuales.</li>
    </ul>

    <h3>Firma</h3>
    <p>public interface JpaRepository&lt;T, ID extends Serializable&gt; 
       extends PagingAndSortingRepository&lt;T, ID&gt;, QueryByExampleExecutor&lt;T&gt;
       <ul>
        <li>T → tipo de la entidad.</li>
        <li>ID → tipo de la clave primaria (ejemplo: Long, UUID, etc).</li>
       </ul>
    </p>

    <h3>Funcionalidades principales</h3>
    <p>Con JpaRepository obtienes de inmediato métodos listos para usar, sin necesidad de implementarlos:</p>
    <b>Operaciones CRUD</b>
    <ul>
        <li>save(S entity) → guarda o actualiza.</li>
        <li>findById(ID id) → busca por id.</li>
        <li>findAll() → lista todas las entidades.</li>
        <li>deleteById(ID id) → elimina por id.</li>
        <li>delete(T entity) → elimina una instancia.</li>
        <li>count() → devuelve el total de registros.</li>
    </ul>
    <b>Paginación y ordenamiento</b>
    <ul>
        <li>findAll(Pageable pageable) → resultados paginados.</li>
        <li>findAll(Sort sort) → resultados ordenados.</li>
        <li>findAll(Pageable pageable, Sort sort) → combinación.</li>
    </ul>
    <b>Consultas derivadas (query methods)</b>
    <p><pre>
        Spring Data JPA analiza el nombre del método y genera automáticamente la consulta:
        List&lt;User&gt; findByLastName(String lastName);
        List&lt;User&gt; findByAgeGreaterThan(int age);
        Optional&lt;User&gt; findByEmail(String email);
    </pre></p>
    <b>Consultas personalizadas</b>
    <p><pre>
        Puedes usar JPQL o SQL nativo con la anotación @Query:
        @Query("SELECT u FROM User u WHERE u.email = ?1")
        Optional&lt;User&gt; findByEmailCustom(String email);
    </pre></p>

    <h3>Ejemplo típico</h3>
    <p><pre>
        Supongamos que tienes una entidad User con ID Long:
        @Entity
        public class User {
            @Id
            @GeneratedValue(strategy = GenerationType.IDENTITY)
            private Long id;
            private String name;
            private String email;
        }

        Tu repositorio sería:
        public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
        List&lt;User&gt; findByName(String name);
        Optional&lt;User&gt; findByEmail(String email);
        }

        En un servicio o controlador puedes inyectarlo:
        @Service
        public class UserService {
            @Autowired
            private UserRepository userRepository;

            public List&lt;pre&gt; allUsers() {
                return userRepository.findAll();
            }
        }
    </pre></p>

    <h3>Ventajas</h3>
    <ul>
        <li>Elimina mucho código repetitivo (no hace falta escribir DAOs manuales).</li>
        <li>Permite consultas dinámicas solo con nombres de métodos.</li>
        <li>Soporta paginación, ordenamiento y transacciones fácilmente.</li>
        <li>Integración fluida con Spring Boot (no necesitas casi configuración).</li>
    </ul>

</div>
